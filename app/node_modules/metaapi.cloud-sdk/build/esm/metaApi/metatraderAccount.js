'use strict';
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
import TimeoutError from '../clients/timeoutError';
import RpcMetaApiConnectionInstance from './rpcMetaApiConnectionInstance';
import StreamingMetaApiConnectionInstance from './streamingMetaApiConnectionInstance';
import HistoryDatabase from './historyDatabase/index';
import ExpertAdvisor from './expertAdvisor';
import { ValidationError } from '../clients/errorHandler';
import MetatraderAccountReplica from './metatraderAccountReplica';
//eslint-disable-next-line max-len
import { Reliability, State, Version, ConnectionStatus, CopyFactoryRoles, Type, AccountConnection, ConfigurationLink } from '../clients/metaApi/metatraderAccount.client';
let MetatraderAccount = class MetatraderAccount {
    /**
   * Returns unique account id
   * @return {string} unique account id
   */ get id() {
        return this._data._id;
    }
    /**
   * Returns current account state. One of CREATED, DEPLOYING, DEPLOYED, DEPLOY_FAILED, UNDEPLOYING,
   * UNDEPLOYED, UNDEPLOY_FAILED, DELETING, DELETE_FAILED, REDEPLOY_FAILED, DRAFT
   * @return {State} current account state
   */ get state() {
        return this._data.state;
    }
    /**
   * Returns MetaTrader magic to place trades using
   * @return {number} MetaTrader magic to place trades using
   */ get magic() {
        return this._data.magic;
    }
    /**
   * Returns terminal & broker connection status, one of CONNECTED, DISCONNECTED, DISCONNECTED_FROM_BROKER
   * @return {ConnectionStatus} terminal & broker connection status
   */ get connectionStatus() {
        return this._data.connectionStatus;
    }
    /**
   * Returns quote streaming interval in seconds 
   * @return {number} quote streaming interval in seconds
   */ get quoteStreamingIntervalInSeconds() {
        return this._data.quoteStreamingIntervalInSeconds;
    }
    /**
   * Returns symbol provided by broker 
   * @return {string} any symbol provided by broker
   */ get symbol() {
        return this._data.symbol;
    }
    /**
   * Returns reliability value. Possible values are regular and high
   * @return {Reliability} account reliability value
   */ get reliability() {
        return this._data.reliability;
    }
    /**
   * Returns user-defined account tags
   * @return {Array<string>} user-defined account tags
   */ get tags() {
        return this._data.tags;
    }
    /**
   * Returns extra information which can be stored together with your account
   * @return {Object} extra information which can be stored together with your account
   */ get metadata() {
        return this._data.metadata;
    }
    /**
   * Returns number of resource slots to allocate to account. Allocating extra resource slots
   * results in better account performance under load which is useful for some applications. E.g. if you have many
   * accounts copying the same strategy via CopyFactory API, then you can increase resourceSlots to get a lower trade
   * copying latency. Please note that allocating extra resource slots is a paid option. Please note that high
   * reliability accounts use redundant infrastructure, so that each resource slot for a high reliability account
   * is billed as 2 standard resource slots.
   * @return {number} number of resource slots to allocate to account
   */ get resourceSlots() {
        return this._data.resourceSlots;
    }
    /**
   * Returns the number of CopyFactory 2 resource slots to allocate to account.
   * Allocating extra resource slots results in lower trade copying latency. Please note that allocating extra resource
   * slots is a paid option. Please also note that CopyFactory 2 uses redundant infrastructure so that
   * each CopyFactory resource slot is billed as 2 standard resource slots. You will be billed for CopyFactory 2
   * resource slots only if you have added your account to CopyFactory 2 by specifying copyFactoryRoles field.
   * @return {number} number of CopyFactory 2 resource slots to allocate to account
   */ get copyFactoryResourceSlots() {
        return this._data.copyFactoryResourceSlots;
    }
    /**
   * Returns account region
   * @return {string} account region value
   */ get region() {
        return this._data.region;
    }
    /**
   * Returns the time account was created at, in ISO format
   * @returns {string} the time account was created at, in ISO format
   */ get createdAt() {
        return new Date(this._data.createdAt);
    }
    /**
   * Returns human-readable account name
   * @return {string} human-readable account name
   */ get name() {
        return this._data.name;
    }
    /**
   * Returns flag indicating if trades should be placed as manual trades on this account
   * @return {boolean} flag indicating if trades should be placed as manual trades on this account
   */ get manualTrades() {
        return this._data.manualTrades;
    }
    /**
   * Returns default trade slippage in points
   * @return {number} default trade slippage in points
   */ get slippage() {
        return this._data.slippage;
    }
    /**
   * Returns id of the account's provisioning profile
   * @return {string} id of the account's provisioning profile
   */ get provisioningProfileId() {
        return this._data.provisioningProfileId;
    }
    /**
   * Returns MetaTrader account login
   * @return {string} MetaTrader account number
   */ get login() {
        return this._data.login;
    }
    /**
   * Returns MetaTrader server name to connect to
   * @return {string} MetaTrader server name to connect to
   */ get server() {
        return this._data.server;
    }
    /**
   * Returns account type. Possible values are cloud-g1, cloud-g2
   * @return {Type} account type
   */ get type() {
        return this._data.type;
    }
    /**
   * Returns MT version. Possible values are 4 and 5
   * @return {Version} MT version
   */ get version() {
        return this._data.version;
    }
    /**
   * Returns hash-code of the account
   * @return {number} hash-code of the account
   */ get hash() {
        return this._data.hash;
    }
    /**
   * Returns 3-character ISO currency code of the account base currency. The setting is to be used
   * for copy trading accounts which use national currencies only, such as some Brazilian brokers. You should not alter
   * this setting unless you understand what you are doing.
   * @return {number} 3-character ISO currency code of the account base currency
   */ get baseCurrency() {
        return this._data.baseCurrency;
    }
    /**
   * Returns account roles for CopyFactory2 application. Possible values are `PROVIDER` and `SUBSCRIBER`
   * @return {Array<CopyFactoryRoles>} account roles for CopyFactory2 application
   */ get copyFactoryRoles() {
        return this._data.copyFactoryRoles;
    }
    /**
   * Returns flag indicating that risk management API is enabled on account
   * @return {boolean} flag indicating that risk management API is enabled on account
   */ get riskManagementApiEnabled() {
        return this._data.riskManagementApiEnabled;
    }
    /**
   * Returns flag indicating that MetaStats API is enabled on account
   * @return {boolean} flag indicating that MetaStats API is enabled on account
   */ get metastatsApiEnabled() {
        return this._data.metastatsApiEnabled;
    }
    /**
   * Returns active account connections
   * @return {Array<AccountConnection>} active account connections
   */ get connections() {
        return this._data.connections;
    }
    /**
   * Returns flag indicating that account is primary
   * @return {boolean} flag indicating that account is primary
   */ get primaryReplica() {
        return this._data.primaryReplica;
    }
    /**
   * Returns user id
   * @return {string} user id
   */ get userId() {
        return this._data.userId;
    }
    /**
   * Returns primary account id
   * @return {string} primary account id
   */ get primaryAccountId() {
        return this._data.primaryAccountId;
    }
    /**
   * Returns account replicas from DTO
   * @return {MetatraderAccountReplica[]} account replicas from DTO
   */ get accountReplicas() {
        return this._data.accountReplicas;
    }
    /**
   * Returns account replica instances
   * @return {MetatraderAccountReplica[]} account replica instances
   */ get replicas() {
        return this._replicas;
    }
    /**
   * Returns a dictionary with account's available regions and replicas
   * @returns {{[region: string]: string}}
   */ get accountRegions() {
        const regions = {
            [this.region]: this.id
        };
        this.replicas.forEach((replica)=>regions[replica.region] = replica.id);
        return regions;
    }
    /**
   * Reloads MetaTrader account from API
   * @return {Promise} promise resolving when MetaTrader account is updated
   */ reload() {
        var _this = this;
        return _async_to_generator(function*() {
            _this._data = yield _this._metatraderAccountClient.getAccount(_this.id);
            const updatedReplicaData = _this._data.accountReplicas || [];
            const regions = updatedReplicaData.map((replica)=>replica.region);
            const createdReplicaRegions = _this._replicas.map((replica)=>replica.region);
            _this._replicas = _this._replicas.filter((replica)=>regions.includes(replica.region));
            _this._replicas.forEach((replica)=>{
                const updatedData = updatedReplicaData.find((replicaData)=>replicaData.region === replica.region);
                replica.updateData(updatedData);
            });
            updatedReplicaData.forEach((replica)=>{
                if (!createdReplicaRegions.includes(replica.region)) {
                    _this._replicas.push(new MetatraderAccountReplica(replica, _this, _this._metatraderAccountClient));
                }
            });
        })();
    }
    /**
   * Removes a trading account and stops the API server serving the account.
   * The account state such as downloaded market data history will be removed as well when you remove the account.
   * @return {Promise} promise resolving when account is scheduled for deletion
   */ remove() {
        var _this = this;
        return _async_to_generator(function*() {
            _this._connectionRegistry.remove(_this.id);
            yield _this._metatraderAccountClient.deleteAccount(_this.id);
            const fileManager = HistoryDatabase.getInstance();
            yield fileManager.clear(_this.id, _this._application);
            if (_this.type !== 'self-hosted') {
                try {
                    yield _this.reload();
                } catch (err) {
                    if (err.name !== 'NotFoundError') {
                        throw err;
                    }
                }
            }
        })();
    }
    /**
   * Starts API server and trading terminal for trading account.
   * This request will be ignored if the account is already deployed.
   * @returns {Promise} promise resolving when account is scheduled for deployment
   */ deploy() {
        var _this = this;
        return _async_to_generator(function*() {
            yield _this._metatraderAccountClient.deployAccount(_this.id);
            yield _this.reload();
        })();
    }
    /**
   * Stops API server and trading terminal for trading account.
   * This request will be ignored if trading account is already undeployed
   * @returns {Promise} promise resolving when account is scheduled for undeployment
   */ undeploy() {
        var _this = this;
        return _async_to_generator(function*() {
            _this._connectionRegistry.remove(_this.id);
            yield _this._metatraderAccountClient.undeployAccount(_this.id);
            yield _this.reload();
        })();
    }
    /**
   * Redeploys trading account. This is equivalent to undeploy immediately followed by deploy
   * @returns {Promise} promise resolving when account is scheduled for redeployment
   */ redeploy() {
        var _this = this;
        return _async_to_generator(function*() {
            yield _this._metatraderAccountClient.redeployAccount(_this.id);
            yield _this.reload();
        })();
    }
    /**
   * Increases trading account reliability in order to increase the expected account uptime.
   * The account will be temporary stopped to perform this action.
   * Note that increasing reliability is a paid option
   * @returns {Promise} promise resolving when account reliability is increased
   */ increaseReliability() {
        var _this = this;
        return _async_to_generator(function*() {
            yield _this._metatraderAccountClient.increaseReliability(_this.id);
            yield _this.reload();
        })();
    }
    /**
   * Enables risk management API for trading account.
   * The account will be temporary stopped to perform this action.
   * Note that risk management API is a paid option
   * @returns {Promise} promise resolving when account risk management is enabled
   */ enableRiskManagementApi() {
        var _this = this;
        return _async_to_generator(function*() {
            yield _this._metatraderAccountClient.enableRiskManagementApi(_this.id);
            yield _this.reload();
        })();
    }
    /**
   * Enables MetaStats API for trading account.
   * The account will be temporary stopped to perform this action.
   * Note that this is a paid option
   * @returns {Promise} promise resolving when account MetaStats API is enabled
   */ enableMetaStatsApi() {
        var _this = this;
        return _async_to_generator(function*() {
            yield _this._metatraderAccountClient.enableMetaStatsApi(_this.id);
            yield _this.reload();
        })();
    }
    /**
   * Waits until API server has finished deployment and account reached the DEPLOYED state
   * @param {number} timeoutInSeconds wait timeout in seconds, default is 5m
   * @param {number} intervalInMilliseconds interval between account reloads while waiting for a change, default is 1s
   * @return {Promise} promise which resolves when account is deployed
   * @throws {TimeoutError} if account have not reached the DEPLOYED state within timeout allowed
   */ waitDeployed(timeoutInSeconds = 300, intervalInMilliseconds = 1000) {
        var _this = this;
        return _async_to_generator(function*() {
            let startTime = Date.now();
            yield _this.reload();
            while(_this.state !== 'DEPLOYED' && startTime + timeoutInSeconds * 1000 > Date.now()){
                yield _this._delay(intervalInMilliseconds);
                yield _this.reload();
            }
            if (_this.state !== 'DEPLOYED') {
                throw new TimeoutError('Timed out waiting for account ' + _this.id + ' to be deployed');
            }
        })();
    }
    /**
   * Waits until API server has finished undeployment and account reached the UNDEPLOYED state
   * @param {number} timeoutInSeconds wait timeout in seconds, default is 5m
   * @param {number} intervalInMilliseconds interval between account reloads while waiting for a change, default is 1s
   * @return {Promise} promise which resolves when account is deployed
   * @throws {TimeoutError} if account have not reached the UNDEPLOYED state within timeout allowed
   */ waitUndeployed(timeoutInSeconds = 300, intervalInMilliseconds = 1000) {
        var _this = this;
        return _async_to_generator(function*() {
            let startTime = Date.now();
            yield _this.reload();
            while(_this.state !== 'UNDEPLOYED' && startTime + timeoutInSeconds * 1000 > Date.now()){
                yield _this._delay(intervalInMilliseconds);
                yield _this.reload();
            }
            if (_this.state !== 'UNDEPLOYED') {
                throw new TimeoutError('Timed out waiting for account ' + _this.id + ' to be undeployed');
            }
        })();
    }
    /**
   * Waits until account has been deleted
   * @param {number} timeoutInSeconds wait timeout in seconds, default is 5m
   * @param {number} intervalInMilliseconds interval between account reloads while waiting for a change, default is 1s
   * @return {Promise} promise which resolves when account is deleted
   * @throws {TimeoutError} if account was not deleted within timeout allowed
   */ waitRemoved(timeoutInSeconds = 300, intervalInMilliseconds = 1000) {
        var _this = this;
        return _async_to_generator(function*() {
            let startTime = Date.now();
            try {
                yield _this.reload();
                while(startTime + timeoutInSeconds * 1000 > Date.now()){
                    yield _this._delay(intervalInMilliseconds);
                    yield _this.reload();
                }
                throw new TimeoutError('Timed out waiting for account ' + _this.id + ' to be deleted');
            } catch (err) {
                if (err.name === 'NotFoundError') {
                    return;
                } else {
                    throw err;
                }
            }
        })();
    }
    /**
   * Waits until API server has connected to the terminal and terminal has connected to the broker
   * @param {number} timeoutInSeconds wait timeout in seconds, default is 5m
   * @param {number} intervalInMilliseconds interval between account reloads while waiting for a change, default is 1s
   * @return {Promise} promise which resolves when API server is connected to the broker
   * @throws {TimeoutError} if account have not connected to the broker within timeout allowed
   */ waitConnected(timeoutInSeconds = 300, intervalInMilliseconds = 1000) {
        var _this = this;
        return _async_to_generator(function*() {
            const checkConnected = ()=>{
                return [
                    _this.connectionStatus
                ].concat(_this.replicas.map((replica)=>replica.connectionStatus)).includes('CONNECTED');
            };
            let startTime = Date.now();
            yield _this.reload();
            while(!checkConnected() && startTime + timeoutInSeconds * 1000 > Date.now()){
                yield _this._delay(intervalInMilliseconds);
                yield _this.reload();
            }
            if (!checkConnected()) {
                throw new TimeoutError('Timed out waiting for account ' + _this.id + ' to connect to the broker');
            }
        })();
    }
    /**
   * Connects to MetaApi. There is only one connection per account. Subsequent calls to this method will return the same connection.
   * @param {HistoryStorage} historyStorage optional history storage
   * @param {Date} [historyStartTime] history start time. Used for tests
   * @return {StreamingMetaApiConnectionInstance} MetaApi connection instance
   */ getStreamingConnection(historyStorage, historyStartTime) {
        if (this._metaApiWebsocketClient.region && this._metaApiWebsocketClient.region !== this.region) {
            throw new ValidationError(`Account ${this.id} is not on specified region ${this._metaApiWebsocketClient.region}`);
        }
        return this._connectionRegistry.connectStreaming(this, historyStorage, historyStartTime);
    }
    /**
   * Connects to MetaApi via RPC connection instance.
   * @returns {RpcMetaApiConnectionInstance} MetaApi connection instance
   */ getRPCConnection() {
        if (this._metaApiWebsocketClient.region && this._metaApiWebsocketClient.region !== this.region) {
            throw new ValidationError(`Account ${this.id} is not on specified region ${this._metaApiWebsocketClient.region}`);
        }
        return this._connectionRegistry.connectRpc(this);
    }
    /**
   * Updates trading account. 
   * Please redeploy the trading account in order for updated settings to take effect
   * @param {MetatraderAccountUpdateDto} account updated account information
   * @return {Promise} promise resolving when account is updated
   */ update(account) {
        var _this = this;
        return _async_to_generator(function*() {
            yield _this._metatraderAccountClient.updateAccount(_this.id, account);
            yield _this.reload();
        })();
    }
    /**
   * Creates a trading account replica in a region different from trading account region and starts a cloud API server for it
   * @param {NewMetaTraderAccountDto} account MetaTrader account data
   * @return {Promise<MetatraderAccountReplica>} promise resolving with created MetaTrader account replica entity
   */ createReplica(account) {
        var _this = this;
        return _async_to_generator(function*() {
            yield _this._metatraderAccountClient.createAccountReplica(_this.id, account);
            yield _this.reload();
            return _this._replicas.find((r)=>r.region === account.region);
        })();
    }
    /**
   * Retrieves expert advisor of current account
   * @returns {Promise<ExpertAdvisor[]>} promise resolving with an array of expert advisor entities
   */ getExpertAdvisors() {
        var _this = this;
        return _async_to_generator(function*() {
            _this._checkExpertAdvisorAllowed();
            let expertAdvisors = yield _this._expertAdvisorClient.getExpertAdvisors(_this.id);
            return expertAdvisors.map((e)=>new ExpertAdvisor(e, _this.id, _this._expertAdvisorClient));
        })();
    }
    /**
   * Retrieves a expert advisor of current account by id
   * @param {String} expertId expert advisor id
   * @returns {Promise<ExpertAdvisor>} promise resolving with expert advisor entity
   */ getExpertAdvisor(expertId) {
        var _this = this;
        return _async_to_generator(function*() {
            _this._checkExpertAdvisorAllowed();
            let expertAdvisor = yield _this._expertAdvisorClient.getExpertAdvisor(_this.id, expertId);
            return new ExpertAdvisor(expertAdvisor, _this.id, _this._expertAdvisorClient);
        })();
    }
    /**
   * Creates an expert advisor
   * @param {string} expertId expert advisor id
   * @param {NewExpertAdvisorDto} expert expert advisor data
   * @returns {Promise<ExpertAdvisor>} promise resolving with expert advisor entity
   */ createExpertAdvisor(expertId, expert) {
        var _this = this;
        return _async_to_generator(function*() {
            _this._checkExpertAdvisorAllowed();
            yield _this._expertAdvisorClient.updateExpertAdvisor(_this.id, expertId, expert);
            return _this.getExpertAdvisor(expertId);
        })();
    }
    /**
   * Returns historical candles for a specific symbol and timeframe from the MetaTrader account.
   * See https://metaapi.cloud/docs/client/restApi/api/retrieveMarketData/readHistoricalCandles/
   * @param {string} symbol symbol to retrieve candles for (e.g. a currency pair or an index)
   * @param {string} timeframe defines the timeframe according to which the candles must be generated. Allowed values
   * for MT5 are 1m, 2m, 3m, 4m, 5m, 6m, 10m, 12m, 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, 1d, 1w, 1mn. Allowed
   * values for MT4 are 1m, 5m, 15m 30m, 1h, 4h, 1d, 1w, 1mn
   * @param {Date} [startTime] time to start loading candles from. Note that candles are loaded in backwards direction, so
   * this should be the latest time. Leave empty to request latest candles.
   * @param {number} [limit] maximum number of candles to retrieve. Must be less or equal to 1000
   * @return {Promise<Array<MetatraderCandle>>} promise resolving with historical candles downloaded
   */ getHistoricalCandles(symbol, timeframe, startTime, limit) {
        return this._historicalMarketDataClient.getHistoricalCandles(this.id, this.region, symbol, timeframe, startTime, limit);
    }
    /**
   * Returns historical ticks for a specific symbol from the MetaTrader account. This API is not supported by MT4
   * accounts.
   * See https://metaapi.cloud/docs/client/restApi/api/retrieveMarketData/readHistoricalTicks/
   * @param {string} symbol symbol to retrieve ticks for (e.g. a currency pair or an index)
   * @param {Date} [startTime] time to start loading ticks from. Note that candles are loaded in forward direction, so
   * this should be the earliest time. Leave empty to request latest candles.
   * @param {number} [offset] number of ticks to skip (you can use it to avoid requesting ticks from previous request
   * twice)
   * @param {number} [limit] maximum number of ticks to retrieve. Must be less or equal to 1000
   * @return {Promise<Array<MetatraderTick>>} promise resolving with historical ticks downloaded
   */ getHistoricalTicks(symbol, startTime, offset, limit) {
        return this._historicalMarketDataClient.getHistoricalTicks(this.id, this.region, symbol, startTime, offset, limit);
    }
    /**
   * Generates trading account configuration link by account id.
   * @param {number} [ttlInDays] Lifetime of the link in days. Default is 7.
   * @return {Promise<ConfigurationLink>} promise resolving with configuration link
   */ createConfigurationLink(ttlInDays) {
        var _this = this;
        return _async_to_generator(function*() {
            const configurationLink = yield _this._metatraderAccountClient.createConfigurationLink(_this.id, ttlInDays);
            return configurationLink;
        })();
    }
    _checkExpertAdvisorAllowed() {
        if (this.version !== 4 || this.type !== 'cloud-g1') {
            throw new ValidationError('Custom expert advisor is available only for MT4 G1 accounts');
        }
    }
    _delay(timeoutInMilliseconds) {
        return new Promise((res)=>setTimeout(res, timeoutInMilliseconds));
    }
    /**
   * Constructs a MetaTrader account entity
   * @param {MetatraderAccountDto} data MetaTrader account data
   * @param {MetatraderAccountClient} metatraderAccountClient MetaTrader account REST API client
   * @param {MetaApiWebsocketClient} metaApiWebsocketClient MetaApi websocket client
   * @param {ConnectionRegistry} connectionRegistry metatrader account connection registry
   * @param {ExpertAdvisorClient} expertAdvisorClient expert advisor REST API client
   * @param {HistoricalMarketDataClient} historicalMarketDataClient historical market data HTTP API client
   * @param {string} application application name
   */ constructor(data, metatraderAccountClient, metaApiWebsocketClient, connectionRegistry, expertAdvisorClient, historicalMarketDataClient, application){
        this._data = data;
        this._metatraderAccountClient = metatraderAccountClient;
        this._metaApiWebsocketClient = metaApiWebsocketClient;
        this._connectionRegistry = connectionRegistry;
        this._expertAdvisorClient = expertAdvisorClient;
        this._historicalMarketDataClient = historicalMarketDataClient;
        this._application = application;
        this._replicas = (data.accountReplicas || []).map((replica)=>new MetatraderAccountReplica(replica, this, metatraderAccountClient));
    }
};
/**
 * Implements a MetaTrader account entity
 */ export { MetatraderAccount as default };

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIjxhbm9uPiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBUaW1lb3V0RXJyb3IgZnJvbSAnLi4vY2xpZW50cy90aW1lb3V0RXJyb3InO1xuaW1wb3J0IFJwY01ldGFBcGlDb25uZWN0aW9uSW5zdGFuY2UgZnJvbSAnLi9ycGNNZXRhQXBpQ29ubmVjdGlvbkluc3RhbmNlJztcbmltcG9ydCBTdHJlYW1pbmdNZXRhQXBpQ29ubmVjdGlvbkluc3RhbmNlIGZyb20gJy4vc3RyZWFtaW5nTWV0YUFwaUNvbm5lY3Rpb25JbnN0YW5jZSc7XG5pbXBvcnQgSGlzdG9yeURhdGFiYXNlIGZyb20gJy4vaGlzdG9yeURhdGFiYXNlL2luZGV4JztcbmltcG9ydCBFeHBlcnRBZHZpc29yIGZyb20gJy4vZXhwZXJ0QWR2aXNvcic7XG5pbXBvcnQge1ZhbGlkYXRpb25FcnJvcn0gZnJvbSAnLi4vY2xpZW50cy9lcnJvckhhbmRsZXInO1xuaW1wb3J0IE1ldGF0cmFkZXJBY2NvdW50UmVwbGljYSBmcm9tICcuL21ldGF0cmFkZXJBY2NvdW50UmVwbGljYSc7XG4vL2VzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG5pbXBvcnQge1JlbGlhYmlsaXR5LCBTdGF0ZSwgVmVyc2lvbiwgQ29ubmVjdGlvblN0YXR1cywgQ29weUZhY3RvcnlSb2xlcywgVHlwZSwgQWNjb3VudENvbm5lY3Rpb24sIENvbmZpZ3VyYXRpb25MaW5rfSBmcm9tICcuLi9jbGllbnRzL21ldGFBcGkvbWV0YXRyYWRlckFjY291bnQuY2xpZW50JztcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgTWV0YVRyYWRlciBhY2NvdW50IGVudGl0eVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNZXRhdHJhZGVyQWNjb3VudCB7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBNZXRhVHJhZGVyIGFjY291bnQgZW50aXR5XG4gICAqIEBwYXJhbSB7TWV0YXRyYWRlckFjY291bnREdG99IGRhdGEgTWV0YVRyYWRlciBhY2NvdW50IGRhdGFcbiAgICogQHBhcmFtIHtNZXRhdHJhZGVyQWNjb3VudENsaWVudH0gbWV0YXRyYWRlckFjY291bnRDbGllbnQgTWV0YVRyYWRlciBhY2NvdW50IFJFU1QgQVBJIGNsaWVudFxuICAgKiBAcGFyYW0ge01ldGFBcGlXZWJzb2NrZXRDbGllbnR9IG1ldGFBcGlXZWJzb2NrZXRDbGllbnQgTWV0YUFwaSB3ZWJzb2NrZXQgY2xpZW50XG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvblJlZ2lzdHJ5fSBjb25uZWN0aW9uUmVnaXN0cnkgbWV0YXRyYWRlciBhY2NvdW50IGNvbm5lY3Rpb24gcmVnaXN0cnlcbiAgICogQHBhcmFtIHtFeHBlcnRBZHZpc29yQ2xpZW50fSBleHBlcnRBZHZpc29yQ2xpZW50IGV4cGVydCBhZHZpc29yIFJFU1QgQVBJIGNsaWVudFxuICAgKiBAcGFyYW0ge0hpc3RvcmljYWxNYXJrZXREYXRhQ2xpZW50fSBoaXN0b3JpY2FsTWFya2V0RGF0YUNsaWVudCBoaXN0b3JpY2FsIG1hcmtldCBkYXRhIEhUVFAgQVBJIGNsaWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXBwbGljYXRpb24gYXBwbGljYXRpb24gbmFtZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZGF0YSwgbWV0YXRyYWRlckFjY291bnRDbGllbnQsIG1ldGFBcGlXZWJzb2NrZXRDbGllbnQsIGNvbm5lY3Rpb25SZWdpc3RyeSwgZXhwZXJ0QWR2aXNvckNsaWVudCwgXG4gICAgaGlzdG9yaWNhbE1hcmtldERhdGFDbGllbnQsIGFwcGxpY2F0aW9uKSB7XG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5fbWV0YXRyYWRlckFjY291bnRDbGllbnQgPSBtZXRhdHJhZGVyQWNjb3VudENsaWVudDtcbiAgICB0aGlzLl9tZXRhQXBpV2Vic29ja2V0Q2xpZW50ID0gbWV0YUFwaVdlYnNvY2tldENsaWVudDtcbiAgICB0aGlzLl9jb25uZWN0aW9uUmVnaXN0cnkgPSBjb25uZWN0aW9uUmVnaXN0cnk7XG4gICAgdGhpcy5fZXhwZXJ0QWR2aXNvckNsaWVudCA9IGV4cGVydEFkdmlzb3JDbGllbnQ7XG4gICAgdGhpcy5faGlzdG9yaWNhbE1hcmtldERhdGFDbGllbnQgPSBoaXN0b3JpY2FsTWFya2V0RGF0YUNsaWVudDtcbiAgICB0aGlzLl9hcHBsaWNhdGlvbiA9IGFwcGxpY2F0aW9uO1xuICAgIHRoaXMuX3JlcGxpY2FzID0gKGRhdGEuYWNjb3VudFJlcGxpY2FzIHx8IFtdKVxuICAgICAgLm1hcChyZXBsaWNhID0+IG5ldyBNZXRhdHJhZGVyQWNjb3VudFJlcGxpY2EocmVwbGljYSwgdGhpcywgbWV0YXRyYWRlckFjY291bnRDbGllbnQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHVuaXF1ZSBhY2NvdW50IGlkXG4gICAqIEByZXR1cm4ge3N0cmluZ30gdW5pcXVlIGFjY291bnQgaWRcbiAgICovXG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5faWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBjdXJyZW50IGFjY291bnQgc3RhdGUuIE9uZSBvZiBDUkVBVEVELCBERVBMT1lJTkcsIERFUExPWUVELCBERVBMT1lfRkFJTEVELCBVTkRFUExPWUlORyxcbiAgICogVU5ERVBMT1lFRCwgVU5ERVBMT1lfRkFJTEVELCBERUxFVElORywgREVMRVRFX0ZBSUxFRCwgUkVERVBMT1lfRkFJTEVELCBEUkFGVFxuICAgKiBAcmV0dXJuIHtTdGF0ZX0gY3VycmVudCBhY2NvdW50IHN0YXRlXG4gICAqL1xuICBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEuc3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBNZXRhVHJhZGVyIG1hZ2ljIHRvIHBsYWNlIHRyYWRlcyB1c2luZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE1ldGFUcmFkZXIgbWFnaWMgdG8gcGxhY2UgdHJhZGVzIHVzaW5nXG4gICAqL1xuICBnZXQgbWFnaWMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEubWFnaWM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0ZXJtaW5hbCAmIGJyb2tlciBjb25uZWN0aW9uIHN0YXR1cywgb25lIG9mIENPTk5FQ1RFRCwgRElTQ09OTkVDVEVELCBESVNDT05ORUNURURfRlJPTV9CUk9LRVJcbiAgICogQHJldHVybiB7Q29ubmVjdGlvblN0YXR1c30gdGVybWluYWwgJiBicm9rZXIgY29ubmVjdGlvbiBzdGF0dXNcbiAgICovXG4gIGdldCBjb25uZWN0aW9uU3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLmNvbm5lY3Rpb25TdGF0dXM7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZXR1cm5zIHF1b3RlIHN0cmVhbWluZyBpbnRlcnZhbCBpbiBzZWNvbmRzIFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IHF1b3RlIHN0cmVhbWluZyBpbnRlcnZhbCBpbiBzZWNvbmRzXG4gICAqL1xuICBnZXQgcXVvdGVTdHJlYW1pbmdJbnRlcnZhbEluU2Vjb25kcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5xdW90ZVN0cmVhbWluZ0ludGVydmFsSW5TZWNvbmRzO1xuICB9XG4gIFxuICAvKipcbiAgICogUmV0dXJucyBzeW1ib2wgcHJvdmlkZWQgYnkgYnJva2VyIFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGFueSBzeW1ib2wgcHJvdmlkZWQgYnkgYnJva2VyXG4gICAqL1xuICBnZXQgc3ltYm9sKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnN5bWJvbDtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFJldHVybnMgcmVsaWFiaWxpdHkgdmFsdWUuIFBvc3NpYmxlIHZhbHVlcyBhcmUgcmVndWxhciBhbmQgaGlnaFxuICAgKiBAcmV0dXJuIHtSZWxpYWJpbGl0eX0gYWNjb3VudCByZWxpYWJpbGl0eSB2YWx1ZVxuICAgKi9cbiAgZ2V0IHJlbGlhYmlsaXR5KCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnJlbGlhYmlsaXR5O1xuICB9XG4gIFxuICAvKipcbiAgICogUmV0dXJucyB1c2VyLWRlZmluZWQgYWNjb3VudCB0YWdzXG4gICAqIEByZXR1cm4ge0FycmF5PHN0cmluZz59IHVzZXItZGVmaW5lZCBhY2NvdW50IHRhZ3NcbiAgICovXG4gIGdldCB0YWdzKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnRhZ3M7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBleHRyYSBpbmZvcm1hdGlvbiB3aGljaCBjYW4gYmUgc3RvcmVkIHRvZ2V0aGVyIHdpdGggeW91ciBhY2NvdW50XG4gICAqIEByZXR1cm4ge09iamVjdH0gZXh0cmEgaW5mb3JtYXRpb24gd2hpY2ggY2FuIGJlIHN0b3JlZCB0b2dldGhlciB3aXRoIHlvdXIgYWNjb3VudFxuICAgKi9cbiAgZ2V0IG1ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLm1ldGFkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbnVtYmVyIG9mIHJlc291cmNlIHNsb3RzIHRvIGFsbG9jYXRlIHRvIGFjY291bnQuIEFsbG9jYXRpbmcgZXh0cmEgcmVzb3VyY2Ugc2xvdHNcbiAgICogcmVzdWx0cyBpbiBiZXR0ZXIgYWNjb3VudCBwZXJmb3JtYW5jZSB1bmRlciBsb2FkIHdoaWNoIGlzIHVzZWZ1bCBmb3Igc29tZSBhcHBsaWNhdGlvbnMuIEUuZy4gaWYgeW91IGhhdmUgbWFueVxuICAgKiBhY2NvdW50cyBjb3B5aW5nIHRoZSBzYW1lIHN0cmF0ZWd5IHZpYSBDb3B5RmFjdG9yeSBBUEksIHRoZW4geW91IGNhbiBpbmNyZWFzZSByZXNvdXJjZVNsb3RzIHRvIGdldCBhIGxvd2VyIHRyYWRlXG4gICAqIGNvcHlpbmcgbGF0ZW5jeS4gUGxlYXNlIG5vdGUgdGhhdCBhbGxvY2F0aW5nIGV4dHJhIHJlc291cmNlIHNsb3RzIGlzIGEgcGFpZCBvcHRpb24uIFBsZWFzZSBub3RlIHRoYXQgaGlnaFxuICAgKiByZWxpYWJpbGl0eSBhY2NvdW50cyB1c2UgcmVkdW5kYW50IGluZnJhc3RydWN0dXJlLCBzbyB0aGF0IGVhY2ggcmVzb3VyY2Ugc2xvdCBmb3IgYSBoaWdoIHJlbGlhYmlsaXR5IGFjY291bnRcbiAgICogaXMgYmlsbGVkIGFzIDIgc3RhbmRhcmQgcmVzb3VyY2Ugc2xvdHMuXG4gICAqIEByZXR1cm4ge251bWJlcn0gbnVtYmVyIG9mIHJlc291cmNlIHNsb3RzIHRvIGFsbG9jYXRlIHRvIGFjY291bnRcbiAgICovXG4gIGdldCByZXNvdXJjZVNsb3RzKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnJlc291cmNlU2xvdHM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIENvcHlGYWN0b3J5IDIgcmVzb3VyY2Ugc2xvdHMgdG8gYWxsb2NhdGUgdG8gYWNjb3VudC5cbiAgICogQWxsb2NhdGluZyBleHRyYSByZXNvdXJjZSBzbG90cyByZXN1bHRzIGluIGxvd2VyIHRyYWRlIGNvcHlpbmcgbGF0ZW5jeS4gUGxlYXNlIG5vdGUgdGhhdCBhbGxvY2F0aW5nIGV4dHJhIHJlc291cmNlXG4gICAqIHNsb3RzIGlzIGEgcGFpZCBvcHRpb24uIFBsZWFzZSBhbHNvIG5vdGUgdGhhdCBDb3B5RmFjdG9yeSAyIHVzZXMgcmVkdW5kYW50IGluZnJhc3RydWN0dXJlIHNvIHRoYXRcbiAgICogZWFjaCBDb3B5RmFjdG9yeSByZXNvdXJjZSBzbG90IGlzIGJpbGxlZCBhcyAyIHN0YW5kYXJkIHJlc291cmNlIHNsb3RzLiBZb3Ugd2lsbCBiZSBiaWxsZWQgZm9yIENvcHlGYWN0b3J5IDJcbiAgICogcmVzb3VyY2Ugc2xvdHMgb25seSBpZiB5b3UgaGF2ZSBhZGRlZCB5b3VyIGFjY291bnQgdG8gQ29weUZhY3RvcnkgMiBieSBzcGVjaWZ5aW5nIGNvcHlGYWN0b3J5Um9sZXMgZmllbGQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gbnVtYmVyIG9mIENvcHlGYWN0b3J5IDIgcmVzb3VyY2Ugc2xvdHMgdG8gYWxsb2NhdGUgdG8gYWNjb3VudFxuICAgKi9cbiAgZ2V0IGNvcHlGYWN0b3J5UmVzb3VyY2VTbG90cygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5jb3B5RmFjdG9yeVJlc291cmNlU2xvdHM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhY2NvdW50IHJlZ2lvblxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGFjY291bnQgcmVnaW9uIHZhbHVlXG4gICAqL1xuICBnZXQgcmVnaW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnJlZ2lvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0aW1lIGFjY291bnQgd2FzIGNyZWF0ZWQgYXQsIGluIElTTyBmb3JtYXRcbiAgICogQHJldHVybnMge3N0cmluZ30gdGhlIHRpbWUgYWNjb3VudCB3YXMgY3JlYXRlZCBhdCwgaW4gSVNPIGZvcm1hdFxuICAgKi9cbiAgZ2V0IGNyZWF0ZWRBdCgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUodGhpcy5fZGF0YS5jcmVhdGVkQXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaHVtYW4tcmVhZGFibGUgYWNjb3VudCBuYW1lXG4gICAqIEByZXR1cm4ge3N0cmluZ30gaHVtYW4tcmVhZGFibGUgYWNjb3VudCBuYW1lXG4gICAqL1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5uYW1lO1xuICB9XG4gIFxuICAvKipcbiAgICogUmV0dXJucyBmbGFnIGluZGljYXRpbmcgaWYgdHJhZGVzIHNob3VsZCBiZSBwbGFjZWQgYXMgbWFudWFsIHRyYWRlcyBvbiB0aGlzIGFjY291bnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gZmxhZyBpbmRpY2F0aW5nIGlmIHRyYWRlcyBzaG91bGQgYmUgcGxhY2VkIGFzIG1hbnVhbCB0cmFkZXMgb24gdGhpcyBhY2NvdW50XG4gICAqL1xuICBnZXQgbWFudWFsVHJhZGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLm1hbnVhbFRyYWRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGRlZmF1bHQgdHJhZGUgc2xpcHBhZ2UgaW4gcG9pbnRzXG4gICAqIEByZXR1cm4ge251bWJlcn0gZGVmYXVsdCB0cmFkZSBzbGlwcGFnZSBpbiBwb2ludHNcbiAgICovXG4gIGdldCBzbGlwcGFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5zbGlwcGFnZTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFJldHVybnMgaWQgb2YgdGhlIGFjY291bnQncyBwcm92aXNpb25pbmcgcHJvZmlsZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGlkIG9mIHRoZSBhY2NvdW50J3MgcHJvdmlzaW9uaW5nIHByb2ZpbGVcbiAgICovXG4gIGdldCBwcm92aXNpb25pbmdQcm9maWxlSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEucHJvdmlzaW9uaW5nUHJvZmlsZUlkO1xuICB9XG4gIFxuICAvKipcbiAgICogUmV0dXJucyBNZXRhVHJhZGVyIGFjY291bnQgbG9naW5cbiAgICogQHJldHVybiB7c3RyaW5nfSBNZXRhVHJhZGVyIGFjY291bnQgbnVtYmVyXG4gICAqL1xuICBnZXQgbG9naW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEubG9naW47XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZXR1cm5zIE1ldGFUcmFkZXIgc2VydmVyIG5hbWUgdG8gY29ubmVjdCB0b1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1ldGFUcmFkZXIgc2VydmVyIG5hbWUgdG8gY29ubmVjdCB0b1xuICAgKi9cbiAgZ2V0IHNlcnZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5zZXJ2ZXI7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhY2NvdW50IHR5cGUuIFBvc3NpYmxlIHZhbHVlcyBhcmUgY2xvdWQtZzEsIGNsb3VkLWcyXG4gICAqIEByZXR1cm4ge1R5cGV9IGFjY291bnQgdHlwZVxuICAgKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEudHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIE1UIHZlcnNpb24uIFBvc3NpYmxlIHZhbHVlcyBhcmUgNCBhbmQgNVxuICAgKiBAcmV0dXJuIHtWZXJzaW9ufSBNVCB2ZXJzaW9uXG4gICAqL1xuICBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS52ZXJzaW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaGFzaC1jb2RlIG9mIHRoZSBhY2NvdW50XG4gICAqIEByZXR1cm4ge251bWJlcn0gaGFzaC1jb2RlIG9mIHRoZSBhY2NvdW50XG4gICAqL1xuICBnZXQgaGFzaCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5oYXNoO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgMy1jaGFyYWN0ZXIgSVNPIGN1cnJlbmN5IGNvZGUgb2YgdGhlIGFjY291bnQgYmFzZSBjdXJyZW5jeS4gVGhlIHNldHRpbmcgaXMgdG8gYmUgdXNlZFxuICAgKiBmb3IgY29weSB0cmFkaW5nIGFjY291bnRzIHdoaWNoIHVzZSBuYXRpb25hbCBjdXJyZW5jaWVzIG9ubHksIHN1Y2ggYXMgc29tZSBCcmF6aWxpYW4gYnJva2Vycy4gWW91IHNob3VsZCBub3QgYWx0ZXJcbiAgICogdGhpcyBzZXR0aW5nIHVubGVzcyB5b3UgdW5kZXJzdGFuZCB3aGF0IHlvdSBhcmUgZG9pbmcuXG4gICAqIEByZXR1cm4ge251bWJlcn0gMy1jaGFyYWN0ZXIgSVNPIGN1cnJlbmN5IGNvZGUgb2YgdGhlIGFjY291bnQgYmFzZSBjdXJyZW5jeVxuICAgKi9cbiAgZ2V0IGJhc2VDdXJyZW5jeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5iYXNlQ3VycmVuY3k7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhY2NvdW50IHJvbGVzIGZvciBDb3B5RmFjdG9yeTIgYXBwbGljYXRpb24uIFBvc3NpYmxlIHZhbHVlcyBhcmUgYFBST1ZJREVSYCBhbmQgYFNVQlNDUklCRVJgXG4gICAqIEByZXR1cm4ge0FycmF5PENvcHlGYWN0b3J5Um9sZXM+fSBhY2NvdW50IHJvbGVzIGZvciBDb3B5RmFjdG9yeTIgYXBwbGljYXRpb25cbiAgICovXG4gIGdldCBjb3B5RmFjdG9yeVJvbGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLmNvcHlGYWN0b3J5Um9sZXM7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZsYWcgaW5kaWNhdGluZyB0aGF0IHJpc2sgbWFuYWdlbWVudCBBUEkgaXMgZW5hYmxlZCBvbiBhY2NvdW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGZsYWcgaW5kaWNhdGluZyB0aGF0IHJpc2sgbWFuYWdlbWVudCBBUEkgaXMgZW5hYmxlZCBvbiBhY2NvdW50XG4gICAqL1xuICBnZXQgcmlza01hbmFnZW1lbnRBcGlFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnJpc2tNYW5hZ2VtZW50QXBpRW5hYmxlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZsYWcgaW5kaWNhdGluZyB0aGF0IE1ldGFTdGF0cyBBUEkgaXMgZW5hYmxlZCBvbiBhY2NvdW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGZsYWcgaW5kaWNhdGluZyB0aGF0IE1ldGFTdGF0cyBBUEkgaXMgZW5hYmxlZCBvbiBhY2NvdW50XG4gICAqL1xuICBnZXQgbWV0YXN0YXRzQXBpRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5tZXRhc3RhdHNBcGlFbmFibGVkO1xuICB9XG4gICAgXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFjdGl2ZSBhY2NvdW50IGNvbm5lY3Rpb25zXG4gICAqIEByZXR1cm4ge0FycmF5PEFjY291bnRDb25uZWN0aW9uPn0gYWN0aXZlIGFjY291bnQgY29ubmVjdGlvbnNcbiAgICovXG4gIGdldCBjb25uZWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5jb25uZWN0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZsYWcgaW5kaWNhdGluZyB0aGF0IGFjY291bnQgaXMgcHJpbWFyeVxuICAgKiBAcmV0dXJuIHtib29sZWFufSBmbGFnIGluZGljYXRpbmcgdGhhdCBhY2NvdW50IGlzIHByaW1hcnlcbiAgICovXG4gIGdldCBwcmltYXJ5UmVwbGljYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5wcmltYXJ5UmVwbGljYTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHVzZXIgaWRcbiAgICogQHJldHVybiB7c3RyaW5nfSB1c2VyIGlkXG4gICAqL1xuICBnZXQgdXNlcklkKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnVzZXJJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHByaW1hcnkgYWNjb3VudCBpZFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHByaW1hcnkgYWNjb3VudCBpZFxuICAgKi9cbiAgZ2V0IHByaW1hcnlBY2NvdW50SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEucHJpbWFyeUFjY291bnRJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFjY291bnQgcmVwbGljYXMgZnJvbSBEVE9cbiAgICogQHJldHVybiB7TWV0YXRyYWRlckFjY291bnRSZXBsaWNhW119IGFjY291bnQgcmVwbGljYXMgZnJvbSBEVE9cbiAgICovXG4gIGdldCBhY2NvdW50UmVwbGljYXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEuYWNjb3VudFJlcGxpY2FzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWNjb3VudCByZXBsaWNhIGluc3RhbmNlc1xuICAgKiBAcmV0dXJuIHtNZXRhdHJhZGVyQWNjb3VudFJlcGxpY2FbXX0gYWNjb3VudCByZXBsaWNhIGluc3RhbmNlc1xuICAgKi9cbiAgZ2V0IHJlcGxpY2FzKCkge1xuICAgIHJldHVybiB0aGlzLl9yZXBsaWNhcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZGljdGlvbmFyeSB3aXRoIGFjY291bnQncyBhdmFpbGFibGUgcmVnaW9ucyBhbmQgcmVwbGljYXNcbiAgICogQHJldHVybnMge3tbcmVnaW9uOiBzdHJpbmddOiBzdHJpbmd9fVxuICAgKi9cbiAgZ2V0IGFjY291bnRSZWdpb25zKCkge1xuICAgIGNvbnN0IHJlZ2lvbnMgPSB7W3RoaXMucmVnaW9uXTogdGhpcy5pZH07XG4gICAgdGhpcy5yZXBsaWNhcy5mb3JFYWNoKHJlcGxpY2EgPT4gcmVnaW9uc1tyZXBsaWNhLnJlZ2lvbl0gPSByZXBsaWNhLmlkKTtcbiAgICByZXR1cm4gcmVnaW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxvYWRzIE1ldGFUcmFkZXIgYWNjb3VudCBmcm9tIEFQSVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHJlc29sdmluZyB3aGVuIE1ldGFUcmFkZXIgYWNjb3VudCBpcyB1cGRhdGVkXG4gICAqL1xuICBhc3luYyByZWxvYWQoKSB7XG4gICAgdGhpcy5fZGF0YSA9IGF3YWl0IHRoaXMuX21ldGF0cmFkZXJBY2NvdW50Q2xpZW50LmdldEFjY291bnQodGhpcy5pZCk7XG4gICAgY29uc3QgdXBkYXRlZFJlcGxpY2FEYXRhID0gKHRoaXMuX2RhdGEuYWNjb3VudFJlcGxpY2FzIHx8IFtdKTtcbiAgICBjb25zdCByZWdpb25zID0gdXBkYXRlZFJlcGxpY2FEYXRhLm1hcChyZXBsaWNhID0+IHJlcGxpY2EucmVnaW9uKTtcbiAgICBjb25zdCBjcmVhdGVkUmVwbGljYVJlZ2lvbnMgPSB0aGlzLl9yZXBsaWNhcy5tYXAocmVwbGljYSA9PiByZXBsaWNhLnJlZ2lvbik7XG4gICAgdGhpcy5fcmVwbGljYXMgPSB0aGlzLl9yZXBsaWNhcy5maWx0ZXIocmVwbGljYSA9PiByZWdpb25zLmluY2x1ZGVzKHJlcGxpY2EucmVnaW9uKSk7XG4gICAgdGhpcy5fcmVwbGljYXMuZm9yRWFjaChyZXBsaWNhID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZWREYXRhID0gdXBkYXRlZFJlcGxpY2FEYXRhLmZpbmQocmVwbGljYURhdGEgPT4gcmVwbGljYURhdGEucmVnaW9uID09PSByZXBsaWNhLnJlZ2lvbik7XG4gICAgICByZXBsaWNhLnVwZGF0ZURhdGEodXBkYXRlZERhdGEpO1xuICAgIH0pO1xuICAgIHVwZGF0ZWRSZXBsaWNhRGF0YS5mb3JFYWNoKHJlcGxpY2EgPT4ge1xuICAgICAgaWYoIWNyZWF0ZWRSZXBsaWNhUmVnaW9ucy5pbmNsdWRlcyhyZXBsaWNhLnJlZ2lvbikpIHtcbiAgICAgICAgdGhpcy5fcmVwbGljYXMucHVzaChuZXcgTWV0YXRyYWRlckFjY291bnRSZXBsaWNhKHJlcGxpY2EsIHRoaXMsIHRoaXMuX21ldGF0cmFkZXJBY2NvdW50Q2xpZW50KSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIHRyYWRpbmcgYWNjb3VudCBhbmQgc3RvcHMgdGhlIEFQSSBzZXJ2ZXIgc2VydmluZyB0aGUgYWNjb3VudC5cbiAgICogVGhlIGFjY291bnQgc3RhdGUgc3VjaCBhcyBkb3dubG9hZGVkIG1hcmtldCBkYXRhIGhpc3Rvcnkgd2lsbCBiZSByZW1vdmVkIGFzIHdlbGwgd2hlbiB5b3UgcmVtb3ZlIHRoZSBhY2NvdW50LlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHJlc29sdmluZyB3aGVuIGFjY291bnQgaXMgc2NoZWR1bGVkIGZvciBkZWxldGlvblxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlKCkge1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25SZWdpc3RyeS5yZW1vdmUodGhpcy5pZCk7XG4gICAgYXdhaXQgdGhpcy5fbWV0YXRyYWRlckFjY291bnRDbGllbnQuZGVsZXRlQWNjb3VudCh0aGlzLmlkKTtcbiAgICBjb25zdCBmaWxlTWFuYWdlciA9IEhpc3RvcnlEYXRhYmFzZS5nZXRJbnN0YW5jZSgpO1xuICAgIGF3YWl0IGZpbGVNYW5hZ2VyLmNsZWFyKHRoaXMuaWQsIHRoaXMuX2FwcGxpY2F0aW9uKTtcbiAgICBpZiAodGhpcy50eXBlICE9PSAnc2VsZi1ob3N0ZWQnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLnJlbG9hZCgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIubmFtZSAhPT0gJ05vdEZvdW5kRXJyb3InKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyBBUEkgc2VydmVyIGFuZCB0cmFkaW5nIHRlcm1pbmFsIGZvciB0cmFkaW5nIGFjY291bnQuXG4gICAqIFRoaXMgcmVxdWVzdCB3aWxsIGJlIGlnbm9yZWQgaWYgdGhlIGFjY291bnQgaXMgYWxyZWFkeSBkZXBsb3llZC5cbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2UgcmVzb2x2aW5nIHdoZW4gYWNjb3VudCBpcyBzY2hlZHVsZWQgZm9yIGRlcGxveW1lbnRcbiAgICovXG4gIGFzeW5jIGRlcGxveSgpIHtcbiAgICBhd2FpdCB0aGlzLl9tZXRhdHJhZGVyQWNjb3VudENsaWVudC5kZXBsb3lBY2NvdW50KHRoaXMuaWQpO1xuICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgQVBJIHNlcnZlciBhbmQgdHJhZGluZyB0ZXJtaW5hbCBmb3IgdHJhZGluZyBhY2NvdW50LlxuICAgKiBUaGlzIHJlcXVlc3Qgd2lsbCBiZSBpZ25vcmVkIGlmIHRyYWRpbmcgYWNjb3VudCBpcyBhbHJlYWR5IHVuZGVwbG95ZWRcbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2UgcmVzb2x2aW5nIHdoZW4gYWNjb3VudCBpcyBzY2hlZHVsZWQgZm9yIHVuZGVwbG95bWVudFxuICAgKi9cbiAgYXN5bmMgdW5kZXBsb3koKSB7XG4gICAgdGhpcy5fY29ubmVjdGlvblJlZ2lzdHJ5LnJlbW92ZSh0aGlzLmlkKTtcbiAgICBhd2FpdCB0aGlzLl9tZXRhdHJhZGVyQWNjb3VudENsaWVudC51bmRlcGxveUFjY291bnQodGhpcy5pZCk7XG4gICAgYXdhaXQgdGhpcy5yZWxvYWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWRlcGxveXMgdHJhZGluZyBhY2NvdW50LiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gdW5kZXBsb3kgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgZGVwbG95XG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHJlc29sdmluZyB3aGVuIGFjY291bnQgaXMgc2NoZWR1bGVkIGZvciByZWRlcGxveW1lbnRcbiAgICovXG4gIGFzeW5jIHJlZGVwbG95KCkge1xuICAgIGF3YWl0IHRoaXMuX21ldGF0cmFkZXJBY2NvdW50Q2xpZW50LnJlZGVwbG95QWNjb3VudCh0aGlzLmlkKTtcbiAgICBhd2FpdCB0aGlzLnJlbG9hZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluY3JlYXNlcyB0cmFkaW5nIGFjY291bnQgcmVsaWFiaWxpdHkgaW4gb3JkZXIgdG8gaW5jcmVhc2UgdGhlIGV4cGVjdGVkIGFjY291bnQgdXB0aW1lLlxuICAgKiBUaGUgYWNjb3VudCB3aWxsIGJlIHRlbXBvcmFyeSBzdG9wcGVkIHRvIHBlcmZvcm0gdGhpcyBhY3Rpb24uXG4gICAqIE5vdGUgdGhhdCBpbmNyZWFzaW5nIHJlbGlhYmlsaXR5IGlzIGEgcGFpZCBvcHRpb25cbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2UgcmVzb2x2aW5nIHdoZW4gYWNjb3VudCByZWxpYWJpbGl0eSBpcyBpbmNyZWFzZWRcbiAgICovXG4gIGFzeW5jIGluY3JlYXNlUmVsaWFiaWxpdHkoKSB7XG4gICAgYXdhaXQgdGhpcy5fbWV0YXRyYWRlckFjY291bnRDbGllbnQuaW5jcmVhc2VSZWxpYWJpbGl0eSh0aGlzLmlkKTtcbiAgICBhd2FpdCB0aGlzLnJlbG9hZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZXMgcmlzayBtYW5hZ2VtZW50IEFQSSBmb3IgdHJhZGluZyBhY2NvdW50LlxuICAgKiBUaGUgYWNjb3VudCB3aWxsIGJlIHRlbXBvcmFyeSBzdG9wcGVkIHRvIHBlcmZvcm0gdGhpcyBhY3Rpb24uXG4gICAqIE5vdGUgdGhhdCByaXNrIG1hbmFnZW1lbnQgQVBJIGlzIGEgcGFpZCBvcHRpb25cbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2UgcmVzb2x2aW5nIHdoZW4gYWNjb3VudCByaXNrIG1hbmFnZW1lbnQgaXMgZW5hYmxlZFxuICAgKi9cbiAgYXN5bmMgZW5hYmxlUmlza01hbmFnZW1lbnRBcGkoKSB7XG4gICAgYXdhaXQgdGhpcy5fbWV0YXRyYWRlckFjY291bnRDbGllbnQuZW5hYmxlUmlza01hbmFnZW1lbnRBcGkodGhpcy5pZCk7XG4gICAgYXdhaXQgdGhpcy5yZWxvYWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGVzIE1ldGFTdGF0cyBBUEkgZm9yIHRyYWRpbmcgYWNjb3VudC5cbiAgICogVGhlIGFjY291bnQgd2lsbCBiZSB0ZW1wb3Jhcnkgc3RvcHBlZCB0byBwZXJmb3JtIHRoaXMgYWN0aW9uLlxuICAgKiBOb3RlIHRoYXQgdGhpcyBpcyBhIHBhaWQgb3B0aW9uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHJlc29sdmluZyB3aGVuIGFjY291bnQgTWV0YVN0YXRzIEFQSSBpcyBlbmFibGVkXG4gICAqL1xuICBhc3luYyBlbmFibGVNZXRhU3RhdHNBcGkoKSB7XG4gICAgYXdhaXQgdGhpcy5fbWV0YXRyYWRlckFjY291bnRDbGllbnQuZW5hYmxlTWV0YVN0YXRzQXBpKHRoaXMuaWQpO1xuICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gIH1cblxuICAvKipcbiAgICogV2FpdHMgdW50aWwgQVBJIHNlcnZlciBoYXMgZmluaXNoZWQgZGVwbG95bWVudCBhbmQgYWNjb3VudCByZWFjaGVkIHRoZSBERVBMT1lFRCBzdGF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dEluU2Vjb25kcyB3YWl0IHRpbWVvdXQgaW4gc2Vjb25kcywgZGVmYXVsdCBpcyA1bVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyBpbnRlcnZhbCBiZXR3ZWVuIGFjY291bnQgcmVsb2FkcyB3aGlsZSB3YWl0aW5nIGZvciBhIGNoYW5nZSwgZGVmYXVsdCBpcyAxc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gYWNjb3VudCBpcyBkZXBsb3llZFxuICAgKiBAdGhyb3dzIHtUaW1lb3V0RXJyb3J9IGlmIGFjY291bnQgaGF2ZSBub3QgcmVhY2hlZCB0aGUgREVQTE9ZRUQgc3RhdGUgd2l0aGluIHRpbWVvdXQgYWxsb3dlZFxuICAgKi9cbiAgYXN5bmMgd2FpdERlcGxveWVkKHRpbWVvdXRJblNlY29uZHMgPSAzMDAsIGludGVydmFsSW5NaWxsaXNlY29uZHMgPSAxMDAwKSB7XG4gICAgbGV0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgYXdhaXQgdGhpcy5yZWxvYWQoKTtcbiAgICB3aGlsZSAodGhpcy5zdGF0ZSAhPT0gJ0RFUExPWUVEJyAmJiAoc3RhcnRUaW1lICsgdGltZW91dEluU2Vjb25kcyAqIDEwMDApID4gRGF0ZS5ub3coKSkge1xuICAgICAgYXdhaXQgdGhpcy5fZGVsYXkoaW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyk7XG4gICAgICBhd2FpdCB0aGlzLnJlbG9hZCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ0RFUExPWUVEJykge1xuICAgICAgdGhyb3cgbmV3IFRpbWVvdXRFcnJvcignVGltZWQgb3V0IHdhaXRpbmcgZm9yIGFjY291bnQgJyArIHRoaXMuaWQgKyAnIHRvIGJlIGRlcGxveWVkJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdhaXRzIHVudGlsIEFQSSBzZXJ2ZXIgaGFzIGZpbmlzaGVkIHVuZGVwbG95bWVudCBhbmQgYWNjb3VudCByZWFjaGVkIHRoZSBVTkRFUExPWUVEIHN0YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0SW5TZWNvbmRzIHdhaXQgdGltZW91dCBpbiBzZWNvbmRzLCBkZWZhdWx0IGlzIDVtXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcnZhbEluTWlsbGlzZWNvbmRzIGludGVydmFsIGJldHdlZW4gYWNjb3VudCByZWxvYWRzIHdoaWxlIHdhaXRpbmcgZm9yIGEgY2hhbmdlLCBkZWZhdWx0IGlzIDFzXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBhY2NvdW50IGlzIGRlcGxveWVkXG4gICAqIEB0aHJvd3Mge1RpbWVvdXRFcnJvcn0gaWYgYWNjb3VudCBoYXZlIG5vdCByZWFjaGVkIHRoZSBVTkRFUExPWUVEIHN0YXRlIHdpdGhpbiB0aW1lb3V0IGFsbG93ZWRcbiAgICovXG4gIGFzeW5jIHdhaXRVbmRlcGxveWVkKHRpbWVvdXRJblNlY29uZHMgPSAzMDAsIGludGVydmFsSW5NaWxsaXNlY29uZHMgPSAxMDAwKSB7XG4gICAgbGV0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgYXdhaXQgdGhpcy5yZWxvYWQoKTtcbiAgICB3aGlsZSAodGhpcy5zdGF0ZSAhPT0gJ1VOREVQTE9ZRUQnICYmIChzdGFydFRpbWUgKyB0aW1lb3V0SW5TZWNvbmRzICogMTAwMCkgPiBEYXRlLm5vdygpKSB7XG4gICAgICBhd2FpdCB0aGlzLl9kZWxheShpbnRlcnZhbEluTWlsbGlzZWNvbmRzKTtcbiAgICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlICE9PSAnVU5ERVBMT1lFRCcpIHtcbiAgICAgIHRocm93IG5ldyBUaW1lb3V0RXJyb3IoJ1RpbWVkIG91dCB3YWl0aW5nIGZvciBhY2NvdW50ICcgKyB0aGlzLmlkICsgJyB0byBiZSB1bmRlcGxveWVkJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdhaXRzIHVudGlsIGFjY291bnQgaGFzIGJlZW4gZGVsZXRlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dEluU2Vjb25kcyB3YWl0IHRpbWVvdXQgaW4gc2Vjb25kcywgZGVmYXVsdCBpcyA1bVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyBpbnRlcnZhbCBiZXR3ZWVuIGFjY291bnQgcmVsb2FkcyB3aGlsZSB3YWl0aW5nIGZvciBhIGNoYW5nZSwgZGVmYXVsdCBpcyAxc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gYWNjb3VudCBpcyBkZWxldGVkXG4gICAqIEB0aHJvd3Mge1RpbWVvdXRFcnJvcn0gaWYgYWNjb3VudCB3YXMgbm90IGRlbGV0ZWQgd2l0aGluIHRpbWVvdXQgYWxsb3dlZFxuICAgKi9cbiAgYXN5bmMgd2FpdFJlbW92ZWQodGltZW91dEluU2Vjb25kcyA9IDMwMCwgaW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyA9IDEwMDApIHtcbiAgICBsZXQgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5yZWxvYWQoKTtcbiAgICAgIHdoaWxlIChzdGFydFRpbWUgKyB0aW1lb3V0SW5TZWNvbmRzICogMTAwMCA+IERhdGUubm93KCkpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fZGVsYXkoaW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyk7XG4gICAgICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgVGltZW91dEVycm9yKCdUaW1lZCBvdXQgd2FpdGluZyBmb3IgYWNjb3VudCAnICsgdGhpcy5pZCArICcgdG8gYmUgZGVsZXRlZCcpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyci5uYW1lID09PSAnTm90Rm91bmRFcnJvcicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXYWl0cyB1bnRpbCBBUEkgc2VydmVyIGhhcyBjb25uZWN0ZWQgdG8gdGhlIHRlcm1pbmFsIGFuZCB0ZXJtaW5hbCBoYXMgY29ubmVjdGVkIHRvIHRoZSBicm9rZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRJblNlY29uZHMgd2FpdCB0aW1lb3V0IGluIHNlY29uZHMsIGRlZmF1bHQgaXMgNW1cbiAgICogQHBhcmFtIHtudW1iZXJ9IGludGVydmFsSW5NaWxsaXNlY29uZHMgaW50ZXJ2YWwgYmV0d2VlbiBhY2NvdW50IHJlbG9hZHMgd2hpbGUgd2FpdGluZyBmb3IgYSBjaGFuZ2UsIGRlZmF1bHQgaXMgMXNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIEFQSSBzZXJ2ZXIgaXMgY29ubmVjdGVkIHRvIHRoZSBicm9rZXJcbiAgICogQHRocm93cyB7VGltZW91dEVycm9yfSBpZiBhY2NvdW50IGhhdmUgbm90IGNvbm5lY3RlZCB0byB0aGUgYnJva2VyIHdpdGhpbiB0aW1lb3V0IGFsbG93ZWRcbiAgICovXG4gIGFzeW5jIHdhaXRDb25uZWN0ZWQodGltZW91dEluU2Vjb25kcyA9IDMwMCwgaW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyA9IDEwMDApIHtcbiAgICBjb25zdCBjaGVja0Nvbm5lY3RlZCA9ICgpID0+IHtcbiAgICAgIHJldHVybiBbdGhpcy5jb25uZWN0aW9uU3RhdHVzXS5jb25jYXQodGhpcy5yZXBsaWNhcy5tYXAocmVwbGljYSA9PiBcbiAgICAgICAgcmVwbGljYS5jb25uZWN0aW9uU3RhdHVzKSkuaW5jbHVkZXMoJ0NPTk5FQ1RFRCcpO1xuICAgIH07XG5cbiAgICBsZXQgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBhd2FpdCB0aGlzLnJlbG9hZCgpO1xuICAgIHdoaWxlICghY2hlY2tDb25uZWN0ZWQoKSAmJiAoc3RhcnRUaW1lICsgdGltZW91dEluU2Vjb25kcyAqIDEwMDApID4gRGF0ZS5ub3coKSkge1xuICAgICAgYXdhaXQgdGhpcy5fZGVsYXkoaW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyk7XG4gICAgICBhd2FpdCB0aGlzLnJlbG9hZCgpO1xuICAgIH1cbiAgICBpZiAoIWNoZWNrQ29ubmVjdGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBUaW1lb3V0RXJyb3IoJ1RpbWVkIG91dCB3YWl0aW5nIGZvciBhY2NvdW50ICcgKyB0aGlzLmlkICsgJyB0byBjb25uZWN0IHRvIHRoZSBicm9rZXInKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29ubmVjdHMgdG8gTWV0YUFwaS4gVGhlcmUgaXMgb25seSBvbmUgY29ubmVjdGlvbiBwZXIgYWNjb3VudC4gU3Vic2VxdWVudCBjYWxscyB0byB0aGlzIG1ldGhvZCB3aWxsIHJldHVybiB0aGUgc2FtZSBjb25uZWN0aW9uLlxuICAgKiBAcGFyYW0ge0hpc3RvcnlTdG9yYWdlfSBoaXN0b3J5U3RvcmFnZSBvcHRpb25hbCBoaXN0b3J5IHN0b3JhZ2VcbiAgICogQHBhcmFtIHtEYXRlfSBbaGlzdG9yeVN0YXJ0VGltZV0gaGlzdG9yeSBzdGFydCB0aW1lLiBVc2VkIGZvciB0ZXN0c1xuICAgKiBAcmV0dXJuIHtTdHJlYW1pbmdNZXRhQXBpQ29ubmVjdGlvbkluc3RhbmNlfSBNZXRhQXBpIGNvbm5lY3Rpb24gaW5zdGFuY2VcbiAgICovXG4gIGdldFN0cmVhbWluZ0Nvbm5lY3Rpb24oaGlzdG9yeVN0b3JhZ2UsIGhpc3RvcnlTdGFydFRpbWUpIHtcbiAgICBpZih0aGlzLl9tZXRhQXBpV2Vic29ja2V0Q2xpZW50LnJlZ2lvbiAmJiB0aGlzLl9tZXRhQXBpV2Vic29ja2V0Q2xpZW50LnJlZ2lvbiAhPT0gdGhpcy5yZWdpb24pIHtcbiAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXG4gICAgICAgIGBBY2NvdW50ICR7dGhpcy5pZH0gaXMgbm90IG9uIHNwZWNpZmllZCByZWdpb24gJHt0aGlzLl9tZXRhQXBpV2Vic29ja2V0Q2xpZW50LnJlZ2lvbn1gXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uUmVnaXN0cnkuY29ubmVjdFN0cmVhbWluZyh0aGlzLCBoaXN0b3J5U3RvcmFnZSwgaGlzdG9yeVN0YXJ0VGltZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29ubmVjdHMgdG8gTWV0YUFwaSB2aWEgUlBDIGNvbm5lY3Rpb24gaW5zdGFuY2UuXG4gICAqIEByZXR1cm5zIHtScGNNZXRhQXBpQ29ubmVjdGlvbkluc3RhbmNlfSBNZXRhQXBpIGNvbm5lY3Rpb24gaW5zdGFuY2VcbiAgICovXG4gIGdldFJQQ0Nvbm5lY3Rpb24oKSB7XG4gICAgaWYodGhpcy5fbWV0YUFwaVdlYnNvY2tldENsaWVudC5yZWdpb24gJiYgdGhpcy5fbWV0YUFwaVdlYnNvY2tldENsaWVudC5yZWdpb24gIT09IHRoaXMucmVnaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFxuICAgICAgICBgQWNjb3VudCAke3RoaXMuaWR9IGlzIG5vdCBvbiBzcGVjaWZpZWQgcmVnaW9uICR7dGhpcy5fbWV0YUFwaVdlYnNvY2tldENsaWVudC5yZWdpb259YFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25SZWdpc3RyeS5jb25uZWN0UnBjKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdHJhZGluZyBhY2NvdW50LiBcbiAgICogUGxlYXNlIHJlZGVwbG95IHRoZSB0cmFkaW5nIGFjY291bnQgaW4gb3JkZXIgZm9yIHVwZGF0ZWQgc2V0dGluZ3MgdG8gdGFrZSBlZmZlY3RcbiAgICogQHBhcmFtIHtNZXRhdHJhZGVyQWNjb3VudFVwZGF0ZUR0b30gYWNjb3VudCB1cGRhdGVkIGFjY291bnQgaW5mb3JtYXRpb25cbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSByZXNvbHZpbmcgd2hlbiBhY2NvdW50IGlzIHVwZGF0ZWRcbiAgICovXG4gIGFzeW5jIHVwZGF0ZShhY2NvdW50KSB7XG4gICAgYXdhaXQgdGhpcy5fbWV0YXRyYWRlckFjY291bnRDbGllbnQudXBkYXRlQWNjb3VudCh0aGlzLmlkLCBhY2NvdW50KTtcbiAgICBhd2FpdCB0aGlzLnJlbG9hZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB0cmFkaW5nIGFjY291bnQgcmVwbGljYSBpbiBhIHJlZ2lvbiBkaWZmZXJlbnQgZnJvbSB0cmFkaW5nIGFjY291bnQgcmVnaW9uIGFuZCBzdGFydHMgYSBjbG91ZCBBUEkgc2VydmVyIGZvciBpdFxuICAgKiBAcGFyYW0ge05ld01ldGFUcmFkZXJBY2NvdW50RHRvfSBhY2NvdW50IE1ldGFUcmFkZXIgYWNjb3VudCBkYXRhXG4gICAqIEByZXR1cm4ge1Byb21pc2U8TWV0YXRyYWRlckFjY291bnRSZXBsaWNhPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBjcmVhdGVkIE1ldGFUcmFkZXIgYWNjb3VudCByZXBsaWNhIGVudGl0eVxuICAgKi9cbiAgYXN5bmMgY3JlYXRlUmVwbGljYShhY2NvdW50KSB7XG4gICAgYXdhaXQgdGhpcy5fbWV0YXRyYWRlckFjY291bnRDbGllbnQuY3JlYXRlQWNjb3VudFJlcGxpY2EodGhpcy5pZCwgYWNjb3VudCk7XG4gICAgYXdhaXQgdGhpcy5yZWxvYWQoKTtcbiAgICByZXR1cm4gdGhpcy5fcmVwbGljYXMuZmluZChyID0+IHIucmVnaW9uID09PSBhY2NvdW50LnJlZ2lvbik7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGV4cGVydCBhZHZpc29yIG9mIGN1cnJlbnQgYWNjb3VudFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFeHBlcnRBZHZpc29yW10+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIGFuIGFycmF5IG9mIGV4cGVydCBhZHZpc29yIGVudGl0aWVzXG4gICAqL1xuICBhc3luYyBnZXRFeHBlcnRBZHZpc29ycygpIHtcbiAgICB0aGlzLl9jaGVja0V4cGVydEFkdmlzb3JBbGxvd2VkKCk7XG4gICAgbGV0IGV4cGVydEFkdmlzb3JzID0gYXdhaXQgdGhpcy5fZXhwZXJ0QWR2aXNvckNsaWVudC5nZXRFeHBlcnRBZHZpc29ycyh0aGlzLmlkKTtcbiAgICByZXR1cm4gZXhwZXJ0QWR2aXNvcnMubWFwKGUgPT4gbmV3IEV4cGVydEFkdmlzb3IoZSwgdGhpcy5pZCwgdGhpcy5fZXhwZXJ0QWR2aXNvckNsaWVudCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIGV4cGVydCBhZHZpc29yIG9mIGN1cnJlbnQgYWNjb3VudCBieSBpZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXhwZXJ0SWQgZXhwZXJ0IGFkdmlzb3IgaWRcbiAgICogQHJldHVybnMge1Byb21pc2U8RXhwZXJ0QWR2aXNvcj59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggZXhwZXJ0IGFkdmlzb3IgZW50aXR5XG4gICAqL1xuICBhc3luYyBnZXRFeHBlcnRBZHZpc29yKGV4cGVydElkKSB7XG4gICAgdGhpcy5fY2hlY2tFeHBlcnRBZHZpc29yQWxsb3dlZCgpO1xuICAgIGxldCBleHBlcnRBZHZpc29yID0gYXdhaXQgdGhpcy5fZXhwZXJ0QWR2aXNvckNsaWVudC5nZXRFeHBlcnRBZHZpc29yKHRoaXMuaWQsIGV4cGVydElkKTtcbiAgICByZXR1cm4gbmV3IEV4cGVydEFkdmlzb3IoZXhwZXJ0QWR2aXNvciwgdGhpcy5pZCwgdGhpcy5fZXhwZXJ0QWR2aXNvckNsaWVudCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBleHBlcnQgYWR2aXNvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwZXJ0SWQgZXhwZXJ0IGFkdmlzb3IgaWRcbiAgICogQHBhcmFtIHtOZXdFeHBlcnRBZHZpc29yRHRvfSBleHBlcnQgZXhwZXJ0IGFkdmlzb3IgZGF0YVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFeHBlcnRBZHZpc29yPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBleHBlcnQgYWR2aXNvciBlbnRpdHlcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUV4cGVydEFkdmlzb3IoZXhwZXJ0SWQsIGV4cGVydCkge1xuICAgIHRoaXMuX2NoZWNrRXhwZXJ0QWR2aXNvckFsbG93ZWQoKTtcbiAgICBhd2FpdCB0aGlzLl9leHBlcnRBZHZpc29yQ2xpZW50LnVwZGF0ZUV4cGVydEFkdmlzb3IodGhpcy5pZCwgZXhwZXJ0SWQsIGV4cGVydCk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RXhwZXJ0QWR2aXNvcihleHBlcnRJZCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBoaXN0b3JpY2FsIGNhbmRsZXMgZm9yIGEgc3BlY2lmaWMgc3ltYm9sIGFuZCB0aW1lZnJhbWUgZnJvbSB0aGUgTWV0YVRyYWRlciBhY2NvdW50LlxuICAgKiBTZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3Jlc3RBcGkvYXBpL3JldHJpZXZlTWFya2V0RGF0YS9yZWFkSGlzdG9yaWNhbENhbmRsZXMvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHJldHJpZXZlIGNhbmRsZXMgZm9yIChlLmcuIGEgY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRpbWVmcmFtZSBkZWZpbmVzIHRoZSB0aW1lZnJhbWUgYWNjb3JkaW5nIHRvIHdoaWNoIHRoZSBjYW5kbGVzIG11c3QgYmUgZ2VuZXJhdGVkLiBBbGxvd2VkIHZhbHVlc1xuICAgKiBmb3IgTVQ1IGFyZSAxbSwgMm0sIDNtLCA0bSwgNW0sIDZtLCAxMG0sIDEybSwgMTVtLCAyMG0sIDMwbSwgMWgsIDJoLCAzaCwgNGgsIDZoLCA4aCwgMTJoLCAxZCwgMXcsIDFtbi4gQWxsb3dlZFxuICAgKiB2YWx1ZXMgZm9yIE1UNCBhcmUgMW0sIDVtLCAxNW0gMzBtLCAxaCwgNGgsIDFkLCAxdywgMW1uXG4gICAqIEBwYXJhbSB7RGF0ZX0gW3N0YXJ0VGltZV0gdGltZSB0byBzdGFydCBsb2FkaW5nIGNhbmRsZXMgZnJvbS4gTm90ZSB0aGF0IGNhbmRsZXMgYXJlIGxvYWRlZCBpbiBiYWNrd2FyZHMgZGlyZWN0aW9uLCBzb1xuICAgKiB0aGlzIHNob3VsZCBiZSB0aGUgbGF0ZXN0IHRpbWUuIExlYXZlIGVtcHR5IHRvIHJlcXVlc3QgbGF0ZXN0IGNhbmRsZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIG1heGltdW0gbnVtYmVyIG9mIGNhbmRsZXMgdG8gcmV0cmlldmUuIE11c3QgYmUgbGVzcyBvciBlcXVhbCB0byAxMDAwXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8TWV0YXRyYWRlckNhbmRsZT4+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIGhpc3RvcmljYWwgY2FuZGxlcyBkb3dubG9hZGVkXG4gICAqL1xuICBnZXRIaXN0b3JpY2FsQ2FuZGxlcyhzeW1ib2wsIHRpbWVmcmFtZSwgc3RhcnRUaW1lLCBsaW1pdCkge1xuICAgIHJldHVybiB0aGlzLl9oaXN0b3JpY2FsTWFya2V0RGF0YUNsaWVudC5nZXRIaXN0b3JpY2FsQ2FuZGxlcyh0aGlzLmlkLCB0aGlzLnJlZ2lvbiwgc3ltYm9sLFxuICAgICAgdGltZWZyYW1lLCBzdGFydFRpbWUsIGxpbWl0KTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFJldHVybnMgaGlzdG9yaWNhbCB0aWNrcyBmb3IgYSBzcGVjaWZpYyBzeW1ib2wgZnJvbSB0aGUgTWV0YVRyYWRlciBhY2NvdW50LiBUaGlzIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IE1UNFxuICAgKiBhY2NvdW50cy5cbiAgICogU2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC9yZXN0QXBpL2FwaS9yZXRyaWV2ZU1hcmtldERhdGEvcmVhZEhpc3RvcmljYWxUaWNrcy9cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gcmV0cmlldmUgdGlja3MgZm9yIChlLmcuIGEgY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHBhcmFtIHtEYXRlfSBbc3RhcnRUaW1lXSB0aW1lIHRvIHN0YXJ0IGxvYWRpbmcgdGlja3MgZnJvbS4gTm90ZSB0aGF0IGNhbmRsZXMgYXJlIGxvYWRlZCBpbiBmb3J3YXJkIGRpcmVjdGlvbiwgc29cbiAgICogdGhpcyBzaG91bGQgYmUgdGhlIGVhcmxpZXN0IHRpbWUuIExlYXZlIGVtcHR5IHRvIHJlcXVlc3QgbGF0ZXN0IGNhbmRsZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0XSBudW1iZXIgb2YgdGlja3MgdG8gc2tpcCAoeW91IGNhbiB1c2UgaXQgdG8gYXZvaWQgcmVxdWVzdGluZyB0aWNrcyBmcm9tIHByZXZpb3VzIHJlcXVlc3RcbiAgICogdHdpY2UpXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIG1heGltdW0gbnVtYmVyIG9mIHRpY2tzIHRvIHJldHJpZXZlLiBNdXN0IGJlIGxlc3Mgb3IgZXF1YWwgdG8gMTAwMFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PE1ldGF0cmFkZXJUaWNrPj59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggaGlzdG9yaWNhbCB0aWNrcyBkb3dubG9hZGVkXG4gICAqL1xuICBnZXRIaXN0b3JpY2FsVGlja3Moc3ltYm9sLCBzdGFydFRpbWUsIG9mZnNldCwgbGltaXQpIHtcbiAgICByZXR1cm4gdGhpcy5faGlzdG9yaWNhbE1hcmtldERhdGFDbGllbnQuZ2V0SGlzdG9yaWNhbFRpY2tzKHRoaXMuaWQsIHRoaXMucmVnaW9uLCBzeW1ib2wsIHN0YXJ0VGltZSwgb2Zmc2V0LCBsaW1pdCk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIHRyYWRpbmcgYWNjb3VudCBjb25maWd1cmF0aW9uIGxpbmsgYnkgYWNjb3VudCBpZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0dGxJbkRheXNdIExpZmV0aW1lIG9mIHRoZSBsaW5rIGluIGRheXMuIERlZmF1bHQgaXMgNy5cbiAgICogQHJldHVybiB7UHJvbWlzZTxDb25maWd1cmF0aW9uTGluaz59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggY29uZmlndXJhdGlvbiBsaW5rXG4gICAqL1xuICBhc3luYyBjcmVhdGVDb25maWd1cmF0aW9uTGluayh0dGxJbkRheXMpIHtcbiAgICBjb25zdCBjb25maWd1cmF0aW9uTGluayA9IGF3YWl0IHRoaXMuX21ldGF0cmFkZXJBY2NvdW50Q2xpZW50LmNyZWF0ZUNvbmZpZ3VyYXRpb25MaW5rKHRoaXMuaWQsIHR0bEluRGF5cyk7XG4gICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25MaW5rO1xuICB9XG5cbiAgX2NoZWNrRXhwZXJ0QWR2aXNvckFsbG93ZWQoKSB7XG4gICAgaWYgKHRoaXMudmVyc2lvbiAhPT0gNCB8fCB0aGlzLnR5cGUgIT09ICdjbG91ZC1nMScpIHtcbiAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ0N1c3RvbSBleHBlcnQgYWR2aXNvciBpcyBhdmFpbGFibGUgb25seSBmb3IgTVQ0IEcxIGFjY291bnRzJyk7XG4gICAgfVxuICB9XG5cbiAgX2RlbGF5KHRpbWVvdXRJbk1pbGxpc2Vjb25kcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIHRpbWVvdXRJbk1pbGxpc2Vjb25kcykpO1xuICB9XG5cbn1cbiJdLCJuYW1lcyI6WyJUaW1lb3V0RXJyb3IiLCJScGNNZXRhQXBpQ29ubmVjdGlvbkluc3RhbmNlIiwiU3RyZWFtaW5nTWV0YUFwaUNvbm5lY3Rpb25JbnN0YW5jZSIsIkhpc3RvcnlEYXRhYmFzZSIsIkV4cGVydEFkdmlzb3IiLCJWYWxpZGF0aW9uRXJyb3IiLCJNZXRhdHJhZGVyQWNjb3VudFJlcGxpY2EiLCJSZWxpYWJpbGl0eSIsIlN0YXRlIiwiVmVyc2lvbiIsIkNvbm5lY3Rpb25TdGF0dXMiLCJDb3B5RmFjdG9yeVJvbGVzIiwiVHlwZSIsIkFjY291bnRDb25uZWN0aW9uIiwiQ29uZmlndXJhdGlvbkxpbmsiLCJNZXRhdHJhZGVyQWNjb3VudCIsImlkIiwiX2RhdGEiLCJfaWQiLCJzdGF0ZSIsIm1hZ2ljIiwiY29ubmVjdGlvblN0YXR1cyIsInF1b3RlU3RyZWFtaW5nSW50ZXJ2YWxJblNlY29uZHMiLCJzeW1ib2wiLCJyZWxpYWJpbGl0eSIsInRhZ3MiLCJtZXRhZGF0YSIsInJlc291cmNlU2xvdHMiLCJjb3B5RmFjdG9yeVJlc291cmNlU2xvdHMiLCJyZWdpb24iLCJjcmVhdGVkQXQiLCJEYXRlIiwibmFtZSIsIm1hbnVhbFRyYWRlcyIsInNsaXBwYWdlIiwicHJvdmlzaW9uaW5nUHJvZmlsZUlkIiwibG9naW4iLCJzZXJ2ZXIiLCJ0eXBlIiwidmVyc2lvbiIsImhhc2giLCJiYXNlQ3VycmVuY3kiLCJjb3B5RmFjdG9yeVJvbGVzIiwicmlza01hbmFnZW1lbnRBcGlFbmFibGVkIiwibWV0YXN0YXRzQXBpRW5hYmxlZCIsImNvbm5lY3Rpb25zIiwicHJpbWFyeVJlcGxpY2EiLCJ1c2VySWQiLCJwcmltYXJ5QWNjb3VudElkIiwiYWNjb3VudFJlcGxpY2FzIiwicmVwbGljYXMiLCJfcmVwbGljYXMiLCJhY2NvdW50UmVnaW9ucyIsInJlZ2lvbnMiLCJmb3JFYWNoIiwicmVwbGljYSIsInJlbG9hZCIsIl9tZXRhdHJhZGVyQWNjb3VudENsaWVudCIsImdldEFjY291bnQiLCJ1cGRhdGVkUmVwbGljYURhdGEiLCJtYXAiLCJjcmVhdGVkUmVwbGljYVJlZ2lvbnMiLCJmaWx0ZXIiLCJpbmNsdWRlcyIsInVwZGF0ZWREYXRhIiwiZmluZCIsInJlcGxpY2FEYXRhIiwidXBkYXRlRGF0YSIsInB1c2giLCJyZW1vdmUiLCJfY29ubmVjdGlvblJlZ2lzdHJ5IiwiZGVsZXRlQWNjb3VudCIsImZpbGVNYW5hZ2VyIiwiZ2V0SW5zdGFuY2UiLCJjbGVhciIsIl9hcHBsaWNhdGlvbiIsImVyciIsImRlcGxveSIsImRlcGxveUFjY291bnQiLCJ1bmRlcGxveSIsInVuZGVwbG95QWNjb3VudCIsInJlZGVwbG95IiwicmVkZXBsb3lBY2NvdW50IiwiaW5jcmVhc2VSZWxpYWJpbGl0eSIsImVuYWJsZVJpc2tNYW5hZ2VtZW50QXBpIiwiZW5hYmxlTWV0YVN0YXRzQXBpIiwid2FpdERlcGxveWVkIiwidGltZW91dEluU2Vjb25kcyIsImludGVydmFsSW5NaWxsaXNlY29uZHMiLCJzdGFydFRpbWUiLCJub3ciLCJfZGVsYXkiLCJ3YWl0VW5kZXBsb3llZCIsIndhaXRSZW1vdmVkIiwid2FpdENvbm5lY3RlZCIsImNoZWNrQ29ubmVjdGVkIiwiY29uY2F0IiwiZ2V0U3RyZWFtaW5nQ29ubmVjdGlvbiIsImhpc3RvcnlTdG9yYWdlIiwiaGlzdG9yeVN0YXJ0VGltZSIsIl9tZXRhQXBpV2Vic29ja2V0Q2xpZW50IiwiY29ubmVjdFN0cmVhbWluZyIsImdldFJQQ0Nvbm5lY3Rpb24iLCJjb25uZWN0UnBjIiwidXBkYXRlIiwiYWNjb3VudCIsInVwZGF0ZUFjY291bnQiLCJjcmVhdGVSZXBsaWNhIiwiY3JlYXRlQWNjb3VudFJlcGxpY2EiLCJyIiwiZ2V0RXhwZXJ0QWR2aXNvcnMiLCJfY2hlY2tFeHBlcnRBZHZpc29yQWxsb3dlZCIsImV4cGVydEFkdmlzb3JzIiwiX2V4cGVydEFkdmlzb3JDbGllbnQiLCJlIiwiZ2V0RXhwZXJ0QWR2aXNvciIsImV4cGVydElkIiwiZXhwZXJ0QWR2aXNvciIsImNyZWF0ZUV4cGVydEFkdmlzb3IiLCJleHBlcnQiLCJ1cGRhdGVFeHBlcnRBZHZpc29yIiwiZ2V0SGlzdG9yaWNhbENhbmRsZXMiLCJ0aW1lZnJhbWUiLCJsaW1pdCIsIl9oaXN0b3JpY2FsTWFya2V0RGF0YUNsaWVudCIsImdldEhpc3RvcmljYWxUaWNrcyIsIm9mZnNldCIsImNyZWF0ZUNvbmZpZ3VyYXRpb25MaW5rIiwidHRsSW5EYXlzIiwiY29uZmlndXJhdGlvbkxpbmsiLCJ0aW1lb3V0SW5NaWxsaXNlY29uZHMiLCJQcm9taXNlIiwicmVzIiwic2V0VGltZW91dCIsImNvbnN0cnVjdG9yIiwiZGF0YSIsIm1ldGF0cmFkZXJBY2NvdW50Q2xpZW50IiwibWV0YUFwaVdlYnNvY2tldENsaWVudCIsImNvbm5lY3Rpb25SZWdpc3RyeSIsImV4cGVydEFkdmlzb3JDbGllbnQiLCJoaXN0b3JpY2FsTWFya2V0RGF0YUNsaWVudCIsImFwcGxpY2F0aW9uIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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